#|1|tam_reg|tamp_c1|c1|t_c2|c2|t_c3|c3|tc4|c4|tc5|c5|tc6|c6|tc7|c7|tc8|c8|tc9|c9|tc10|c10

Para remover
#|0|...

Caso o espaço seja reaproveitado
#|1|tam_regAtual-tamRegAntigo|...|#|0|Sobras


A estrategia de reaproveitamento de espaço será First-Fit, pois em questão de tempo ela é a mais rápida.


Como vai funcionar:

Inserção:

Ler o registro da mesma forma, que foi lido na outra parte, mas na hora de escrever muda:

O que fazer:

-Calcular o tamanho do registro, como:

->10 * sizeof(int) = 40
->20
->tamanho dos campos

-Verificar a existencia de remoção lógicas que podem ser reaproveitadas pelo registro de tamanho calculado

-Caso exista: Insere na posição trocando 0 para 1, e realizar uma subtração entre o tamanho do registro atual e o que foi removido,
colocar o registro, e caso o resultado da subtração for algum valor maior que 0, escrever apos o final do registro, isto, o arquivo deve ser aberto
no modo rb+

Pensa-se dessa maneira, todo registro, que tiver espaço sobrando deve ter escrito:
#|0|20| -> Isso é do tamanho 4 + 4+ 1 = 9, logo todo registro que nao tiver tamanho igual, deve ser 9 bytes maior que o novo registro,
logo a conta de subtração feita deve ser regRemovido - reginserido ou deve ser igual a 0, ou >=9, caso nao for, nao pode ser inserido nessa localidade.
#|0|subtração-3-sizeof(int)-1|, mas tam, que será escrito, será no minimo igual a 8, pois o |(delimitador) conta como uma posição

-Caso não exista:

-EScrever o registro na ordem especificada acima, para isso pode-se abrir o arquivo do modo ab

De qualquer modo, calcula-se o byte offset do #, isto é a posição do # e guarda no arquivo de chaves secundárias com o byte offset

-----------------------------------------------------------------------------------------------------------------------------------

Remoção:

-Realizar a busca sequencial da chave até encontrar o byte offset do registro que contenha a chave x,

Como chave é o primeiro campo escrito, então ao ler o campo chave, caso for igual, volta sizeof(key)4+2*sizeof(int), e escreve 0 no lugar do 1, e também remove
a chave do arquivo de indice que contenha o byte offset do registro


------------------------------------------------------------------------------------------------------------------------------------

Busca:

Busca pela chave secundária é igual

Busca pela chave primária KEY, faz de forma sequencial, caso a chave for diferente, avança-se x posições que será dada pela conta:

tamReg - 2 - sizeof(int) - sizeof(c1) + SEEK_CURR, que direciona para o próximo campo.

--------------------------------------------------------------------------------------------------------------------------------------


Instruções para realizar a função busca_key:

int  busca_key(FILE *arquivo,long int key,int *pos,int *tam,char nome[10],int booleano);


Oque representa cada variavel:

arquivo-Ponteiro para um arquivo
key - representa a chave que quer ser buscada
pos- uma variavel que foi passada por referencia, e representa o byte offset da chave que está sendo procurada, o byteofsset é o byte do #
tam - tamanho do registro que contém a chave key, também passado como referencia
nome- campo do registro com chave key, util para o processo de remoção no arquivo de chaves secundárias
booleano - variavel que afirma se terá algum print ou não, útil para a remoção/inserção que chamam essa função para verificar a existencia da chave


Como vai funcionar:

Inicialmente, deve-se abrir o arquivo no modo r(O arquivo NOME_ARQUIVO), então inicia-se a leitura, do modo padrão igualmente ao que acontece na função leitura,
entretanto como se quer a chave key, ela esta no primeiro campo do registro, logo é muito simples obté-la, deve-se ler:

O #|1|tam|tam_key|KEY, caso for diferente de key, então deve-se avançar até o próximo registro, para isso pode-se ultilizar o campo tam, que representa o tamanho
do registro em si, entretanto deve-se atentar que foi avançado alguns bytes, mais especificamente 2 + sizeof(int) + sizeof(long int), e assim fazer um
pulo = tam - (2 + sizeof(int) + sizeof(long int))
fseek(arquivo,pulo,SEEK_CURR)

E então repetir o processo.

Caso encontre a chave, deve se ler até o campo nome, lendo os tamanhos do campo, o campo nome é o terceiro campo do registro, e terminar